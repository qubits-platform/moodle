!function(){"use strict";function e(e,n){if(!(e instanceof n))throw TypeError("Cannot call a class as a function")}function n(e,n){for(var t=0;t<n.length;t++){var s=n[t];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}function t(e,t,s){return t&&n(e.prototype,t),s&&n(e,s),e}function s(e,n){return(s=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}function i(e,n){if("function"!=typeof n&&null!==n)throw TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&s(e,n)}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function a(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct||Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch(e){return!1}}();return function(){var t,s,i=o(e);if(n){var a=o(this).constructor;s=Reflect.construct(i,arguments,a)}else s=i.apply(this,arguments);return(t=s)&&("object"==(t&&t.constructor===Symbol?"symbol":typeof t)||"function"==typeof t)?t:function(e){if(void 0===e)throw ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(this)}}var l="https://cdn.jsdelivr.net/pyodide/v0.21.0/full/",r=function(){function n(){e(this,n)}return t(n,null,[{key:"create",value:function(){return self.sessionStorage?new u:new d}}]),n}(),d=function(n){i(o,n);var s=a(o);function o(){var n;return e(this,o),(n=s.call(this)).fs={},n}return t(o,[{key:"getDir",value:function(){return Object.keys(this.fs)}},{key:"getFile",value:function(e){return this.fs[e]}},{key:"setFile",value:function(e,n){this.fs[e]=n}}]),o}(r),u=function(n){i(o,n);var s=a(o);function o(){return e(this,o),s.apply(this,arguments)}return t(o,[{key:"getDir",value:function(){return Object.keys(self.sessionStorage)}},{key:"getFile",value:function(e){return self.sessionStorage.getItem(e)}},{key:"setFile",value:function(e,n){self.sessionStorage.setItem(e,n)}}]),o}(r),c=function(){function n(t){e(this,n),this.pyodide=null,this.postExec=t&&t.postExec||function(){},this.write=t&&t.write||function(e){},this.clearText=t&&t.clearText||function(){},this.setFigureURL=t&&t.setFigureURL||function(e){},this.notifyDirtyFile=t&&t.notifyDirtyFile||function(e){},this.notifyStatus=t&&t.notifyStatus||function(e){},this.handleInput=t&&t.handleInput||!1,this.inlineInput=t&&t.inlineInput||!1,this.pyodideURL=t&&t.pyodideURL||l;var s=/\/(v[\d.]+)\//.exec(this.pyodideURL);this.pyodideVersion=s?s[1]:"",this.requestInput=!1,this.inputPrompt=null,this.suspended=!1,this.dbgCurrentLine=null,this.preLoadedPackages=null==t?void 0:t.preLoadedPackages,this.requestedModuleNames=[],this.loadedModuleNames=[],this.failedModuleNames=[],this.fs=r.create(),this.dirtyFiles=[]}return t(n,[{key:"load",value:function(e){var n=this;this.notifyStatus("loading Pyodide "+this.pyodideVersion),console.log("Using new syntax for worker"),globalThis.loadPyodide({indexURL:this.pyodideURL}).then(function(t){n.pyodide=t,n.pyodideVersion=t.version,n.notifyStatus("setup"),self.pyodideGlobal={requestModule:function(e){return n.requestModule(e)},fs:n.fs,markFileDirty:function(e){return n.markFileDirty(e)},setDbgCurrentLine:function(e){n.dbgCurrentLine=e}},n.preLoadedPackages.forEach(function(e){n.notifyStatus("pre-loading "+e),n.pyodide.loadPackage(e).then(function(){n.loadedModuleNames.push(e)}).catch(function(t){n.failedModuleNames.push(e),n.notifyStatus("error pre-loading "+e+t)})}),n.pyodide.runPython('\n                import sys\n                import io\n                from js import pyodideGlobal\n\n                class __ImportIntercept:\n                    def find_spec(self, name, path, module):\n                        pyodideGlobal.requestModule(name)\n                sys.meta_path.append(__ImportIntercept())\n\n                class MyTextFile(io.StringIO):\n                    def __init__(self, filename, mode="r"):\n                        self.filename = filename\n                        self.readOnly = mode == "r"\n                        content = pyodideGlobal.fs.getFile(filename)\n                        if content is None:\n                            if self.readOnly:\n                                raise FileNotFoundError(filename)\n                            content = ""\n                        else:\n                            if mode == "w":\n                                content = ""\n                            elif mode == "x":\n                                raise FileExistsError(filename)\n                        super().__init__(content if content is not None else "")\n                        if mode == "a":\n                            self.seek(0, 2)\n                    def close(self):\n                        if not self.readOnly:\n                            content = self.getvalue()\n                            pyodideGlobal.fs.setFile(self.filename, content)\n                            pyodideGlobal.markFileDirty(self.filename)\n                            super().close()\n\n                def open(filename, mode="r", encoding=None):\n                    return MyTextFile(filename, mode)\n\n                import os\n\n                def __os_listdir(path="."):\n                    return list(pyodideGlobal.fs.getDir())\n                os.listdir = __os_listdir\n\n                # user code execution\n                global_variables = {\n                    "open": open,\n                    "input": input\n                }\n\n                # global debugger\n                dbg = None\n\n                def execute_code(src, breakpoints=None):\n                    """Return 0 if done, 1 if suspended in debugger, 2 if waiting for input"""\n\n                    class Dbg:\n\n                        import sys\n                        import os\n                        import re\n\n                        class Suspended(Exception):\n                            pass\n\n                        class SuspendedForInput(Suspended):\n                            pass\n\n                        def __init__(self, interactive=True):\n                            self.interactive = interactive\n                            self.frame = None\n\n                            # breakpoint line numbers\n                            self.breakpoints = set()\n                            self.break_at_start = True\n                            # past actions or inputs from the user\n                            # ("c"=continue, "n"=next, "s"=step, "r"=return, etc.)\n                            # resume will execute them and suspend execution when they are exhausted\n                            self.debug_action_history = []\n                            # True to ignore trace calls until 2nd event="call"\n                            self.ignore_top_call = False\n                            # substitution for input global function\n                            self.input_debug = None\n\n                            self.last_command = ""\n\n                            self.init_output()\n                            self.null = open(self.os.devnull, "w")\n\n                        def init_output(self):\n                            self.stdout = self.sys.stdout\n                            self.stderr = self.sys.stderr\n\n                        def enable_print(self, on):\n                            self.sys.stdout = self.stdout if on else self.null\n                            self.sys.stderr = self.stderr if on else self.null\n\n                        def clear_breakspoints(self):\n                            self.breakpoints = set()\n\n                        def set_breakpoint(self, lineno):\n                            self.breakpoints.add(lineno)\n\n                        def clear_breakspoint(self, lineno):\n                            self.breakpoints.remove(lineno)\n\n                        def is_suspended(self):\n                            return self.frame is not None\n\n                        def is_requesting_input(self):\n                            return self.request_input\n\n                        def debug_(self, fun, ignore_top_call, args, kwargs):\n                            self.fun = fun\n                            self.args = args\n                            self.kwargs = kwargs\n                            self.ignore_top_call = ignore_top_call\n                            self.returned_value = None\n                            self.debug_action_history = []\n                            self.resume(None)\n                            if self.interactive:\n                                self.cli()\n\n                        def debug_call(self, fun, *args, **kwargs):\n                            self.debug_(fun, False, args, kwargs)\n\n                        def debug_code(self, code, globals=globals(), locals=None):\n                            def input(prompt):\n                                return self.input_debug(prompt)\n                            globals["input"] = input\n                            self.debug_(lambda: exec(code, globals, locals), True, (), {})\n\n                        def resume(self, cmd):\n                            if cmd is not None:\n                                self.debug_action_history.append(cmd)\n\n                            # state ("s"=step, "n"=next, "r"=return, "c"=continue)\n                            state = "s" if self.break_at_start else "c"\n                            # index of first action in self.debug_action_history to perform\n                            action_count = 0\n                            # call depth used for "n" and "r"\n                            call_depth = 0\n                            last_break_depth = 0\n                            # number of event "call"\n                            call_count = 0\n\n                            def trace(frame, event, arg):\n                                nonlocal state, action_count, call_depth, last_break_depth, call_count\n                                if self.ignore_top_call:\n                                    if event == "call":\n                                        if frame.f_code.co_name == "input":\n                                            if action_count >= len(self.debug_action_history):\n                                                # call to input(prompt): display prompt and request user input\n                                                if frame.f_locals["prompt"] is not None:\n                                                    self.sys.stdout.write(frame.f_locals["prompt"])\n                                                self.frame = frame\n                                                raise self.SuspendedForInput()\n                                            else:\n                                                # execute input() defined below (picks input in self.debug_action_history)\n                                                pass\n                                        call_count += 1\n                                        call_depth += 1\n                                    if call_count < 2:\n                                        return\n                                if event == "line":\n                                    self.current_line = frame.f_lineno\n                                    if (state == "n" and call_depth <= last_break_depth or\n                                        state == "r" and call_depth < last_break_depth or\n                                        state == "s" or\n                                        frame.f_lineno in self.breakpoints):\n                                        # breakpoint (explicit, or following s/n/r which should break here)\n                                        if action_count >= len(self.debug_action_history):\n                                            # not reached yet: really break here\n                                            self.frame = frame\n                                            raise self.Suspended()\n                                        else:\n                                            # already reached: continue\n                                            state = self.debug_action_history[action_count]\n                                            action_count += 1\n                                            last_break_depth = call_depth\n                                            if action_count >= len(self.debug_action_history):\n                                                self.enable_print(True)\n                                    elif action_count >= len(self.debug_action_history):\n                                        self.enable_print(True)\n                                elif event == "call":\n                                    call_depth += 1\n                                elif event == "return":\n                                    call_depth -= 1\n                                return trace\n\n                            def input(prompt):\n                                nonlocal action_count\n                                str = self.debug_action_history[action_count]\n                                action_count += 1\n                                return str\n                            self.input_debug = input\n\n                            suspended = False\n                            self.request_input = False\n                            self.enable_print(len(self.debug_action_history) <= 1)\n                            self.sys.settrace(trace)\n                            try:\n                                self.returned_value = self.fun(*self.args, **self.kwargs)\n                            except self.SuspendedForInput:\n                                suspended = True\n                                self.request_input = True\n                            except self.Suspended:\n                                suspended = True\n                            finally:\n                                self.sys.settrace(None)\n                                self.enable_print(True)\n                            if not suspended:\n                                self.frame = None\n\n                        def eval_code(self, src):\n                            try:\n                                code = compile(src, "<stdin>", "single")\n                                exec(code,\n                                     self.frame.f_globals,\n                                     self.frame.f_locals)\n                            except Exception as e:\n                                import traceback\n                                traceback.print_exception(etype=type(e),\n                                                          value=e,\n                                                          tb=e.__traceback__)\n\n                        def exec_cmd(self, cmd):\n                            cmd = cmd.strip() or self.last_command\n                            r = self.re.compile(r"^(S+)(s+(S+))$")\n                            match = r.match(cmd)\n                            if match:\n                                cmd0 = match.groups()[0]\n                                arg = match.groups()[2]\n                            else:\n                                cmd0 = cmd\n                                arg = None\n                            if cmd0 in ["b", "break"]:\n                                if arg is None:\n                                    print(self.breakpoints)\n                                else:\n                                    try:\n                                        lineno = int(arg)\n                                        self.set_breakpoint(lineno)\n                                    except:\n                                        print("Bad line number")\n                                self.last_command = ""\n                            elif cmd in ["c", "continue"]:\n                                self.resume("c")\n                                self.last_command = cmd\n                            elif cmd0 in ["cl", "clear"]:\n                                if arg:\n                                    try:\n                                        lineno = int(arg)\n                                        self.clear_breakspoint(lineno)\n                                    except:\n                                        print("Bad line number")\n                                else:\n                                    self.clear_breakspoints()\n                                self.last_command = ""\n                            elif cmd in ["h", "help"]:\n                                import textwrap\n                                print(textwrap.dedent("""\n                                    b(reak) line  break at specified line\n                                    c(ontinue)    continue\n                                    cl(ear)       clear all breakpoints\n                                    h(elp)        help\n                                    q(quit)       quit\n                                    r(eturn)      continue until the current function returns\n                                    s(tep)        step\n                                    w(here)       display a stack trace\n                                    expr          evaluate expression, including local and global variables\n                                    """))\n                                self.last_command = ""\n                            elif cmd in ["q", "quit"]:\n                                self.frame = None\n                            elif cmd in ["n", "next"]:\n                                self.resume("n")\n                                self.last_command = cmd\n                            elif cmd in ["r", "return"]:\n                                self.resume("r")\n                                self.last_command = cmd\n                            elif cmd in ["s", "step"]:\n                                self.resume("s")\n                                self.last_command = cmd\n                            elif cmd in ["w", "where"]:\n                                frame = self.frame\n                                while frame and (frame.f_code.co_name != "resume"):\n                                    print(f"{frame.f_code.co_name} at line {frame.f_lineno}")\n                                    frame = frame.f_back\n                            elif cmd != "":\n                                self.eval_code(cmd)\n\n                            # return true when execution is completed\n                            return self.frame is None\n\n                        def submit_input(self, input):\n                            self.debug_action_history.append(input)\n                            self.resume(None)\n\n                        def cli(self):\n                            while self.is_suspended():\n                                cmd = input(f"{self.frame.f_code.co_name}:{self.frame.f_lineno} dbg> ")\n                                self.exec_cmd(cmd)\n\n                    try:\n                        code = compile(src, "<stdin>", mode="single")\n                    except SyntaxError:\n                        code = compile(src, "<stdin>", mode="exec")\n\n                    if breakpoints:\n                        global dbg\n                        dbg = Dbg(False)\n                        dbg.break_at_start = False;\n                        for breakpoint in breakpoints:\n                            dbg.set_breakpoint(breakpoint)\n                        dbg.debug_code(code, globals=global_variables)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n                    else:\n                        exec(code, global_variables)\n                        return 0\n\n                def continue_debugging(dbg_command):\n                    if dbg is not None and dbg.is_suspended():\n                        dbg.init_output()  # can be a new io.StringIO() object\n                        dbg.exec_cmd(dbg_command)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n\n                def submit_input_to_debugger(input):\n                    if dbg is not None and dbg.is_suspended() and dbg.request_input:\n                        dbg.init_output()  # can be a new io.StringIO() object\n                        dbg.submit_input(input)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n\n                def debug_current_line():\n                    return dbg.current_line if dbg and dbg.is_suspended() else None\n            '),e&&e()})}},{key:"requestModule",value:function(e){0>this.requestedModuleNames.indexOf(e)&&0>this.loadedModuleNames.indexOf(e)&&0>this.failedModuleNames.indexOf(e)&&this.requestedModuleNames.push(e)}},{key:"markFileDirty",value:function(e){0>this.dirtyFiles.indexOf(e)&&(this.dirtyFiles.push(e),this.notifyDirtyFile(e))}},{key:"getDirtyFilePaths",value:function(e){var n=this.dirtyFiles;return e&&(this.dirtyFiles=[]),n}},{key:"run",value:function(e,n){var t=this;if(""===e.trim())return!0;this.pyodide.runPython("\n            import io, sys\n            sys.stdout = io.StringIO()\n            sys.stderr = sys.stdout\n        "),this.loadedModuleNames.indexOf("matplotlib")>=0&&this.pyodide.runPython('\n                import matplotlib\n                matplotlib.use("Agg")\n            '),this.handleInput&&this.pyodide.runPython('\n                class CodeWithInputEvaluator:\n\n                    def __init__(self, src, global_variables):\n\n                        import ast\n\n                        def check_node(node, block_reason=None):\n                            """Check that input function is called only from where it is supported,\n                            i.e. at top-level if block_reason is None, not in functions or methods, and\n                            nowhere if block_reason is a string describing the offending context. Raise\n                            an exception otherwise.\n                            """\n                            if type(node) is ast.ClassDef:\n                                block_reason = "class"\n                            elif type(node) is ast.FunctionDef:\n                                block_reason = "def"\n                            elif type(node) is ast.Lambda:\n                                block_reason = "lambda"\n                            elif block_reason and type(node) is ast.Call and type(node.func) is ast.Name and node.func.id == "input":\n                                raise Exception(f"input call not supported in {block_reason} at line {node.lineno}")\n                            for child in ast.iter_child_nodes(node):\n                                check_node(child, block_reason)\n\n                        def check(src):\n                            """Check that input function is called only from where it is supported,\n                            i.e. at top-level, not in functions or methods. Raise an exception otherwise.\n                            """\n                            root = ast.parse(src)\n                            check_node(root)\n\n                        def replace_input_with_yield(src, function_name, global_var_names=[]):\n\n                            """Compile source code and replace input calls with yield.\n                            """\n                            class Replacer(ast.NodeTransformer):\n                                """NodeTransformer which replaces input(prompt) with\n                                yield((False,prompt,locals()))\n                                """\n                                def visit_Call(self, node):\n                                    self.generic_visit(node)\n                                    if type(node.func) is ast.Name and node.func.id == "input":\n                                        input_arg = node.args[0] if len(node.args) > 0 else ast.NameConstant(value=None)\n                                        y = ast.Yield(value=ast.Tuple(\n                                            elts=[\n                                                ast.NameConstant(value=False),\n                                                input_arg,\n                                                ast.Call(func=ast.Name(id="locals", ctx=ast.Load()), args=[], keywords=[])\n                                            ],\n                                            ctx=ast.Load()\n                                        ))\n                                        return y\n                                    return node\n\n                            # compile to ast\n                            root = ast.parse(src)\n\n                            # check that input is called only from top-level code, not functions\n                            check_node(root)\n\n                            # replace input(prompt) with yield (False,prompt,locals())\n                            replacer = Replacer()\n                            root1 = replacer.visit(root)\n\n                            # replace last statement with "import sys; sys.displayhook(expr)" if it is an expr\n                            last_el = root1.body[-1]\n                            if type(last_el) is ast.Expr:\n                                expr = root1.body.pop()\n                                root1.body.append(ast.Import(\n                                    names=[\n                                        ast.alias(name="sys", asname=None)\n                                    ]\n                                ))\n                                root1.body.append(ast.Expr(\n                                    value=ast.Call(\n                                        func=ast.Attribute(attr="displayhook", value=ast.Name(id="sys", ctx=ast.Load()), ctx=ast.Load()),\n                                        args=[expr.value],\n                                        keywords=[]\n                                    )\n                                ))\n\n                            # append yield (True,None,locals())\n                            y = ast.Expr(\n                                value=ast.Yield(value=ast.Tuple(\n                                    elts=[\n                                        ast.NameConstant(value=True),\n                                        ast.NameConstant(value=None),\n                                        ast.Call(func=ast.Name(id="locals", ctx=ast.Load()), args=[], keywords=[])\n                                    ],\n                                    ctx=ast.Load()\n                                ))\n                            )\n                            root1.body.append(y)\n\n                            # define a coroutine\n                            root1.body = [\n                                ast.FunctionDef(\n                                    name=function_name,\n                                    args=ast.arguments(\n                                        posonlyargs=[],\n                                        args=[ast.arg(arg=g, annotation=None) for g in global_var_names],\n                                        defaults=[],\n                                        kwarg=None,\n                                        kw_defaults=[],\n                                        kwonlyargs=[],\n                                        vararg=None\n                                    ),\n                                    body=root1.body,\n                                    decorator_list=[],\n                                    returns=None\n                                )\n                            ]\n\n                            # add dummy missing lineno and col_offset to make compiler happy\n                            for node in ast.walk(root1):\n                                if not hasattr(node, "lineno"):\n                                    node.lineno = 1\n                                if not hasattr(node, "col_offset"):\n                                    node.col_offset = 999\n\n                            # compile\n                            code = compile(root1, "<ast>", "exec")\n\n                            return code\n\n                        def run_code_with_input_as_coroutine(src, global_variables):\n                            code = replace_input_with_yield(src, "corout", global_variables)\n                            gl = {}\n                            exec(code, gl)\n                            co = gl["corout"](**global_variables)\n                            return co\n\n                        self.global_variables = global_variables\n                        self.co = run_code_with_input_as_coroutine(src, global_variables)\n                        self.done, self.prompt, new_global_variables = self.co.send(None)\n                        self.global_variables.update(new_global_variables)\n\n                    def submit_input(self, input):\n                        self.done, self.prompt, new_global_variables = self.co.send(input)\n                        self.global_variables.update(new_global_variables)\n\n                    def cancel_input(self):\n                        self.co.close()\n            ');var s="";this.requestedModuleNames=[],this.suspended=!1,this.dbgCurrentLine=null;try{if(this.notifyStatus("running"),self.pyodideGlobal.setFigureURL=function(e){return t.setFigureURL(e)},this.pyodide.globals.set("src",e),n&&n.length>0){var i="["+n.map(function(e){return e.toString(10)}).join(", ")+"]";this.pyodide.runPython("\n                    import js\n                    status = execute_code(src, breakpoints=".concat(i,")\n                    suspended = status != 0\n                    done = not suspended\n                    js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n                ")),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2===this.pyodide.globals.get("status"),this.inputPrompt=null}else this.handleInput?(this.pyodide.runPython("evaluator = CodeWithInputEvaluator(src, global_variables)"),this.requestInput=!1,this.pyodide.runPython("\n                    done = evaluator.done\n                    suspended = False\n                    # suspended = evaluator.suspended\n                    input_prompt = evaluator.prompt\n                "),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||(this.inputPrompt=this.pyodide.globals.get("input_prompt"),this.requestInput=!0)):this.pyodide.runPython("execute_code(src); done = True; suspended = False");this.loadedModuleNames.indexOf("matplotlib")>=0&&this.pyodide.runPython('\n                    import matplotlib.pyplot, io, base64, js\n                    if matplotlib.pyplot.get_fignums():\n                        with io.BytesIO() as buf:\n                            matplotlib.pyplot.savefig(buf, format="png")\n                            buf.seek(0)\n                            js.pyodideGlobal.setFigureURL("data:image/png;base64," +\n                                base64.b64encode(buf.read()).decode("ascii"))\n                ')}catch(n){if(/ModuleNotFoundError/.test(n.message)&&this.requestedModuleNames.length>0){var o=this.requestedModuleNames.shift();return this.notifyStatus("loading module "+o),this.pyodide.loadPackage(o).then(function(){t.loadedModuleNames.push(o),t.notifyStatus("running"),t.run(e)}).catch(function(){t.failedModuleNames.push(o),t.postExec&&t.postExec()}),!1}s=n.message,this.pyodide.globals.set("done",!0)}var a=this.pyodide.runPython("sys.stdout.getvalue()");return this.write(a+s),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(void 0==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec(),!0}},{key:"submitInput",value:function(e){if(this.requestInput){this.pyodide.runPython("\n                import io, sys\n                sys.stdout = io.StringIO()\n                sys.stderr = sys.stdout\n            "),this.inlineInput||this.write((void 0==this.inputPrompt?"? ":this.inputPrompt)+e+"\n"),this.requestInput=!1,self.input_string=e;var n="";if(this.suspended)try{this.pyodide.runPython("\n                        import js\n                        status = submit_input_to_debugger(js.input_string)\n                        suspended = status != 0\n                        done = not suspended\n                        js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n                    "),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2==this.pyodide.globals.get("status"),this.inputPrompt=null}catch(e){}else try{this.pyodide.runPython("\n                        import js\n                        evaluator.submit_input(js.input_string)\n                        done = evaluator.done\n                        # suspended = evaluator.suspended\n                        input_prompt = evaluator.prompt\n                    "),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||(this.inputPrompt=this.pyodide.globals.get("input_prompt"),this.requestInput=!0)}catch(e){n=e.message,this.pyodide.globals.set("done",!0)}var t=this.pyodide.runPython("sys.stdout.getvalue()");this.write(t+n),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(void 0==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec()}}},{key:"cancelInput",value:function(){if(this.requestInput){this.requestInput=!1;try{this.pyodide.runPython("evaluator.cancel_input()")}catch(e){}this.dbgCurrentLine=null}}},{key:"continueDebugging",value:function(e){this.pyodide.runPython("import io, syssys.stdout = io.StringIO()sys.stderr = sys.stdout");try{self.dbg_command=e,this.pyodide.runPython("\n                import js\n                status = continue_debugging(js.dbg_command)\n                suspended = status != 0\n                done = not suspended\n                js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n            "),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2==this.pyodide.globals.get("status"),this.inputPrompt=null}catch(e){}var n=this.pyodide.runPython("sys.stdout.getvalue()");this.write(n),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(void 0==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec()}},{key:"clearFigure",value:function(){this.loadedModuleNames.indexOf("matplotlib")>=0&&(this.pyodide.runPython("\n                import matplotlib.pyplot\n                matplotlib.pyplot.close()\n            "),this.setFigureURL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="))}},{key:"clear",value:function(){this.clearText(),this.clearFigure()}}]),n}();importScripts("".concat(l,"pyodide.js"));var p=!1,f=!1,g="",h=-1,m=null;function _(e,n){postMessage({cmd:"status",status:n&&n.length>0?"debugging":"running"}),m.run(e,n)}onmessage=function(e){var n,t=function(e){var n={write:function(e){g+=e},clearText:function(){g="",f=!0},setFigureURL:function(e){postMessage({cmd:"figure",data:e})},notifyStatus:function(e){postMessage({cmd:"status",status:e})},notifyDirtyFile:function(e){postMessage({cmd:"dirty",data:e})},postExec:function(){var e;(h=e=Date.now())<0?h=e+10:h<=e&&(f&&(postMessage({cmd:"clear"}),f=!1),g&&(postMessage({cmd:"print",data:g}),g=""),h=-1),postMessage({cmd:"done",suspendedAt:m.suspended?m.dbgCurrentLine:null}),m.requestInput&&postMessage({cmd:"input",prompt:m.inputPrompt})},handleInput:e&&e.handleInput||!1,inlineInput:e&&e.inlineInput||!1,preLoadedPackages:(null==e?void 0:e.preLoadedPackages)||[],pyodideURL:l};console.log("options inside worker: ",n),m=new c(n)},s=JSON.parse(e.data);if("config"===s.cmd)t(s.options);else switch(null==m&&t(),s.cmd){case"preload":postMessage({cmd:"status",status:"startup"}),m.load(function(){p=!0,postMessage({cmd:"done"})});break;case"run":p?_(s.code,s.breakpoints):(postMessage({cmd:"status",status:"startup"}),m.load(function(){_(s.code,s.breakpoints),p=!0}));break;case"submit":n=s.str,m.submitInput(n,void 0);break;case"cancel":m.cancelInput();break;case"debug":if(p&&m.suspended)switch(s.dbg){case"next":case"step":case"return":case"continue":case"quit":m.continueDebugging(s.dbg)}else postMessage({cmd:"done"});break;case"get":postMessage({cmd:"file",path:s.path,data:m.fs.getFile(s.path)});break;case"put":m.fs.setFile(s.path,s.data);break;case"clearFigure":m.clearFigure()}}}(),_N_E={};